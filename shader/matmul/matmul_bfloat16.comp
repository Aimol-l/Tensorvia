#version 460

// 需要启动bfloat16扩展 和 int64扩展
#extension GL_EXT_bfloat16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable

#define TILE 16
layout(local_size_x = TILE, local_size_y = TILE, local_size_z = 1) in;

layout(push_constant) uniform Params {
    uint batch;
    uint N; // cols
    uint K; // reduction dim
    uint M; // rows
} params;

layout(std430, binding = 0) buffer InputA {
    bfloat16_t data[];
} A; // [batch, M, K]

layout(std430, binding = 1) buffer InputB {
    bfloat16_t data[];
} B; // [batch, K, N]

layout(std430, binding = 2) buffer Output {
    bfloat16_t data[];
} C; // [batch, M, N]

// Shared memory tiles
shared bfloat16_t tileA[TILE][TILE + 1]; // +1 to avoid bank conflicts
shared bfloat16_t tileB[TILE][TILE + 1];

void main() {
    uint wg_batch = gl_WorkGroupID.z;        // batch index
    uint wg_m = gl_WorkGroupID.y;            // block row in output
    uint wg_n = gl_WorkGroupID.x;            // block col in output

    uint local_m = gl_LocalInvocationID.y;   // thread row in block
    uint local_n = gl_LocalInvocationID.x;   // thread col in block

    // 输出位置
    uint global_m = wg_m * TILE + local_m;
    uint global_n = wg_n * TILE + local_n;

    // 累加器
    float acc = 0;

    // 分片迭代
    uint numTiles = (params.K + TILE - 1) / TILE;
    for (uint tile = 0; tile < numTiles; ++tile) {
        // --- 加载 A tile: [TILE, TILE] from global A[wg_batch, global_m, k_start : k_start+TILE]
        uint k_start = tile * TILE;
        uint a_k = k_start + local_n; // 注意：A 按行主序，每行 K 个
        if (global_m < params.M && a_k < params.K) {
            uint a_idx = wg_batch * params.M * params.K + global_m * params.K + a_k;
            tileA[local_m][local_n] = A.data[a_idx];
        } else {
            tileA[local_m][local_n] = bfloat16_t(0);
        }
        // --- 加载 B tile: [TILE, TILE] from global B[wg_batch, k_start : k_start+TILE, global_n]
        uint b_k = k_start + local_m;
        if (b_k < params.K && global_n < params.N) {
            uint b_idx = wg_batch * params.K * params.N + b_k * params.N + global_n;
            tileB[local_m][local_n] = B.data[b_idx];
        } else {
            tileB[local_m][local_n] = bfloat16_t(0);
        }
        // 同步 workgroup
        barrier();
        for (uint k = 0; k < TILE; ++k) {
            acc += float(tileA[local_m][k]) * float(tileB[k][local_n]);
        }
        barrier();
    }
    if (global_m < params.M && global_n < params.N) {
        uint c_idx = wg_batch * params.M * params.N + global_m * params.N + global_n;
        C.data[c_idx] = bfloat16_t(acc);
    }
}